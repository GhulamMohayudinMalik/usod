\section{Discussion}

The development of USOD made us learn that theory and practice of security operations tend to be different. This part is a retrospect of the engineering reality in connecting AI and blockchain, what worked well, what failed us, and what unexpectedly happened.

\subsection{Engineering Insights}

\subsubsection{The Payload Problem}
The first architecture error we committed was to attempt to store complete payload packets on the blockchain. It appeared to be a good idea in order to complete the picture, permanence of the whole crime scene. In practice, it was a disaster. The size of transactions had soared to more than 50KB, and the Raft consensus layer was crashing even with a load of 30 transactions a second.

The solution was that we did not need the \textit{data} on-chain, but the \textit{proof} of data in the form of the data. Dramatically reducing the payload size (only the SHA-256 hash of it) increased throughput to more than 100 TPS and the count of blocks dropped to 0. The moral of this is; make the ledger slim. Leverage it to be validated, and not stored.

\subsubsection{Why Two Models Are Better Than One}

Our initially chosen Classifier was the Random Forest one. An accuracy of 99.88\% is sufficient to make things more difficult, right? However, as the synthetic tests were done with synthetic zero-day traffic, the Random Forest was proven to be certain in its foolishness, it entailed new attacks under familiar circumstances.

The Isolation Forest was added and was a safety net. It produced greater noise (marking suspicious non-beneficial administrative traffic), yet SOC environment, silence is worse than noise. Every operator that tested the system would rather have false positives than the horrifying prospect of having no feedback. The hybrid method sacrifices a limited level of automation in favor of a huge coverage.

\subsubsection{The Reality of Mobile Background Tasks}
Persistent connections are hostile to mobile operating systems. The implementation of our WebSocket that worked flawlessly with our Android platform would crash silently after some 30 seconds of background time on our iOS app. None of these error messages, no socket close events, the loss of data. We were forced to switch to an adaptive polling system with iOS, which is not as graceful, but, in fact, provides the notices. It is a wake up call that defensive security tools exist under the goodwill of OS power management policies.

\subsection{Known Limitations}

We want to be transparent about what USOD cannot do yet:

\begin{enumerate}
    \item \textbf{It's currently a single-organization network.} We needed one MSP (Membership Service Provider) in our Hyperledger. A real-world value is achieved by sharing a ledger with several organizations (i.e, an ISP and a bank) to cross-verify threats. That involves sophisticated governance that we are yet to fix.
    
    \item \textbf{Encrypted traffic is a blind spot.} We consider flow statistics, but not the content of payloads. In the event that malware encapsulates the malware command-and-control traffic in TLS and recreates the timing of a Netflix stream, we may not be warned to it. This is a major drawback of flow-based detection.
    
    
    \item \textbf{The dataset is aging.} CICIDS2017 is wonderful, yet attack tradecraft is swift. In our training data, fileless malware and low-forms of supply-chain injections are not represented properly. The model requires continuous intake of fresh samples to be relevant.
    
    \item \textbf{10 Gbps is the ceiling.} The Python capture layer begins to drop packets at very large data rates. To be able to deploy carrier-grade, we would re-implement the ingestion engine in C++ or Rust, which probably would use DPDK to bypass the kernel.
\end{enumerate}

\subsection{Deployment Advice}

To the user planning to implement such a system (or anything like it): place your sensor in a place where it can see (network egress points are preferable). Separate your blockchain neighbors, in case your API server is compromised, you do not want the attacker to use it and pivot to the ledger. And train up thy models again, please. A dynamic threat environment with a static model is nothing but a system with legacy that is only going to break down.