\section{Implementation Challenges and Solutions}

\subsection{Blockchain Throughput Tuning}

Hyperledger Fabric's default configuration prioritizes throughput over latency, often introducing a 2-second delay for block cutting. For USOD, where intrusion alerts must be persisted in near real-time, we tuned the ordering service parameters in \texttt{configtx.yaml}. We set \texttt{BatchTimeout} to 2 seconds and reduced \texttt{MaxMessageCount} to 10. This forces the Raft leader to cut a block whenever 10 threat logs accumulate or 2 seconds elapse, whichever comes first, balancing network jitter with audit timeliness.

\subsection{Mobile State Synchronization}

React Native background process limitations on iOS posed a significant hurdle for real-time awareness, as the operating system suspends WebSocket connections when apps are in background states. To guarantee alert delivery without excessive battery drain, we implemented an adaptive polling mechanism. The client calculates a dynamic polling interval $T_p$ based on the \texttt{AppState}: a 5-second active poll ($T_{active} = 5s$) switches to a background fetch strategy where permitted.

\begin{lstlisting}[language=JavaScript, caption=Adaptive Polling Logic]
useEffect(() => {
  let intervalId;
  const poll = () => {
    fetchThreats().then(setThreats);
  };
  poll(); // Initial fetch
  intervalId = setInterval(poll, 5000); // Active polling
  return () => clearInterval(intervalId);
}, []);
\end{lstlisting}

This stateless approach proved more robust than maintaining fragile persistent connections over cellular networks.

\subsection{Desktop Focus Injection}

Electron's security sandbox interferes with programmatic focus shifting. To allow critical alerts to preempt user activity, we injected a custom preload script into the renderer process:

\begin{lstlisting}[language=JavaScript, caption=Electron Focus Context Isolation Bypass]
mainWindow.webContents.executeJavaScript(`
  document.addEventListener('security-alert', (e) => {
    if (e.detail.severity === 'CRITICAL') {
       window.focus(); // Force window to foreground
    }
  });
`);
\end{lstlisting}

\subsection{Continuous Integration and Deployment}

The delivery pipeline is automated via GitHub Actions to ensure code integrity across the polyglot stack. The workflow performs three validation stages:
\begin{enumerate}
    \item \textbf{Static Analysis}: Linting for Node.js (ESLint) and Python (Flake8).
    \item \textbf{Container Build}: Docker Compose builds the \texttt{backend}, \texttt{ai-service}, and \texttt{blockchain-peer} images, validating the Dockerfiles.
    \item \textbf{Regression Testing}: A script simulates the full boot sequence, verifying that the Hyperledger Orderer establishes a quorum before the API layer attempts connection.
\end{enumerate}

\subsection{RESTful API Design}

The backend exposes a RESTful interface adhering to OpenAPI specifications. Table \ref{tab:api} summarizes the primary route groups. We deliberately rejected GraphQL because its query flexibility complicates rate limiting and introduces denial-of-service vectors via deeply nested queries.

\begin{table}[htbp]
\caption{Backend API Route Summary}
\label{tab:api}
\centering
\begin{tabular}{lcp{4.5cm}}
\toprule
\textbf{Route Prefix} & \textbf{Count} & \textbf{Purpose} \\
\midrule
/api/auth & 10 & Authentication, JWT refresh \\
/api/network & 12 & Monitoring, threat retrieval \\
/api/blockchain & 6 & Ledger health, verification \\
/api/backup & 7 & Create, restore backups \\
/api/users & 8 & CRUD, role assignment \\
/api/data & 4 & Dashboard statistics \\
/api/stream & 1 & SSE real-time alerts \\
\midrule
\textbf{Total} & \textbf{48} & \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Centralized Security Logging}

Every security-relevant action, whether successful or failed, is written to MongoDB with the schema depicted in Listing 3. The \texttt{action} field is an enumerated type spanning more than 40 event categories (e.g., \texttt{network\_intrusion}, \texttt{ip\_blocked}, \texttt{user\_created}). This granularity enables post-incident filtering without parsing unstructured text.

\begin{lstlisting}[language=JavaScript, caption=SecurityLog Schema]
{
  userId: ObjectId,
  username: String,
  action: String (enum: 40+ types),
  status: "success" | "failure",
  ipAddress: String,
  userAgent: String,
  details: Object,
  timestamp: Date (indexed)
}
\end{lstlisting}

Compound indexes on \texttt{(timestamp, action)} accelerate the common query pattern: ``show me all IP blocks from the last 24 hours.'' Without these indexes, the dashboard's log viewer degraded to multi-second response times during load testing.
