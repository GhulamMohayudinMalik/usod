\subsection{Backend Security Detection Engine}

The backend implementation is built on Node.js with Express.js, providing a high-performance API server capable of handling thousands of concurrent security operations. The server implements a modular architecture with clear separation of concerns between security detection, data management, and API handling.

\textbf{Core Server Architecture}: The Express.js server is configured with comprehensive middleware including CORS handling, request parsing, authentication, and security validation. The server implements a microservices-inspired architecture where each major functionality is encapsulated in separate modules, enabling independent testing and maintenance.

\textbf{MongoDB Integration}: Data persistence is handled through MongoDB with Mongoose ODM, providing flexible schema design and efficient querying capabilities. The database schema is optimized for security event storage with compound indexes on frequently queried fields such as timestamp, IP address, and event type.

\subsubsection{Security Pattern Detection}

The security detection engine implements a comprehensive pattern-matching system that identifies 12+ attack types in real-time. The pattern detection system uses regular expressions and behavioral analysis to identify malicious activities with high accuracy and low false positive rates.

\begin{lstlisting}[language=JavaScript, caption=Security Pattern Detection Implementation, basicstyle=\footnotesize\ttfamily, breaklines=true]
// Security pattern definitions
const SECURITY_PATTERNS = {
  SQL_INJECTION: [
    /union\s+select/i, /drop\s+table/i, /or\s+1\s*=\s*1/i
  ],
  XSS: [
    /<script[^>]*>.*?<\/script>/gi, /javascript:/gi
  ],
  CSRF: [
    /<form[^>]*action[^>]*>/gi, /<img[^>]*src[^>]*>/gi
  ]
  // ... additional patterns for 9 more attack types
};

export function detectSecurityThreats(input, req) {
  const threats = [];
  for (const [threatType, patterns] of Object.entries(SECURITY_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(input)) {
        threats.push({
          type: threatType,
          pattern: pattern.toString(),
          input: input.substring(0, 100)
        });
      }
    }
  }
  return threats;
}
\end{lstlisting}

\subsubsection{Real-time Event Processing}

The event processing system implements a high-performance pipeline that processes security events in real-time with sub-200ms response times. The system uses an event-driven architecture with an internal event bus for immediate communication between components.

\begin{lstlisting}[language=JavaScript, caption=Event Bus and Security Processing, basicstyle=\footnotesize\ttfamily, breaklines=true]
// Event bus implementation
import { EventEmitter } from 'events';
export const eventBus = new EventEmitter();

// Security check middleware
export function performSecurityCheck(req, res, next) {
  const ip = getRealIP(req);
  
  if (isIPBlocked(ip)) {
    return res.status(403).json({
      message: 'Access denied: IP blocked',
      code: 'IP_BLOCKED'
    });
  }
  
  if (req.body) {
    const bodyString = JSON.stringify(req.body);
    const threats = detectSecurityThreats(bodyString, req);
    
    if (threats.length > 0) {
      logSecurityEvent(null, 'detected', req, {
        eventType: threats[0].type,
        severity: 'high',
        source: ip
      });
      
      blockIP(ip, threats[0].type);
      eventBus.emit('security.threat_detected', {
        ip, threats, timestamp: new Date()
      });
      
      return res.status(400).json({
        message: 'Malicious input detected',
        code: 'SECURITY_THREAT_DETECTED'
      });
    }
  }
  next();
}

// IP management system
const blockedIPs = new Set();
export function blockIP(ip, reason = 'security_violation') {
  blockedIPs.add(ip);
  eventBus.emit('ip.blocked', { ip, reason, timestamp: new Date() });
  setTimeout(() => unblockIP(ip, 'automatic_timeout'), 3600000);
}
\end{lstlisting}
